[toc]

## Exercise 3-4 

 In a two's complement number representation, our version of itoa does not handle the largest negative number, that is, the value of $n$ equal to $-2^{wordsize-1}$. Explain why not. Modify it to print that value correctly, regardless of the machine on which it runs.

## Answers:

### 数据的存储方式

数据的表现形式为原码,反码和补码三种形式. 虽然我们通常使用的都是原码形式, 但是计算机内部的数据存储方式一般用补码的形式, 这是因为使用补码的形式可以用加法的方式来完成减法操作.

为了简便考虑, 我们假设有符号整数为8位(实际上这与计算机本身有关),其最高位用来表示符号位, 0为正, 1为负;剩余的7位则用来表示数据.下面我们用数字123来做示范

1. 原码 (原码就是对数做一个进制转换, 最后在符号位设置一个符号)

   正数 +123 :  0111 1011

   负数 -123 :  1111 1011

2. 反码 (正数的反码和原码一样; 负数的反码则是符号位不动, 其余位取反)
   正数 +123 :  0111 1011
   负数 -123 :  1000 0100

3. 补码 (正数的补码和原码一样; 负数的补码是反码+1)

   正数 +123 :  0111 1011
   负数 -123 :  1000 0101

### 整数的取值范围

由于前面提到的正数的补码等价于补码, 因此 0000 0000~0111 1111 表示从+0到127, 对于负数的补码形式, 用的是1000 0001~1111 1111表示从-1 到-127.但值得注意的是此处并没有用到 1000 0000,这实际上是因为找不到一个对应的数满足这个补码形式,但是由于1000 0000+0111 111=1111 1111=-1, 所以直接假设1000 0000为-128.

### 同余理论解释补码

由于一个 n 位的二进制数有 $2^n$ 的数据组合类型, 以 $n=8$ 为例, 那么他就有 256 中可能的组合, 因此我们可以用256进行求模操作,进而我们可以得到如下的同余的关系,
$$
\begin{aligned}
-128&\equiv128(\textrm{mod}256)\\
-127&\equiv129(\textrm{mod}256)\\
&\cdots\\
-1&\equiv255(\textrm{mod}256)\\
\end{aligned}
$$
因此可见在 $256$ 的求模运算下, 加减法使用 0~255 和 -128~127是等价的, 不仅如此,这样操作会使得符号位的运算不需要进行特殊处理; 再换言之可以认为0000 0000~1111 1111 实际上是一个连续的数值区间.

有了这些认识, 我们可以理解为什么用1000 0000 来表示-128, 按照同余的观点,他的补码应该是和模-其绝对值相等,也就是256-128,即1 0000 0000-1000 000=1000 0000.不仅如此,从这个角度来看, 我们还可以直观的看出为什么负数的补码的计算方式是反码+1,下面我们用-123为例验证
$$
\begin{aligned}
256-123&= 1\ 0000\ 0000-0111\ 1011\\
&=(1111\ 1111+0000\ 0001)-0111\ 1011\\
&=1000\ 0100(\text{反码形式})+0000\ 0001\\
&=1000\ 0101
\end{aligned}
$$

### 关于本题的解释

由于选用的负数是 $-2^{wordsize-1}$, 在程序中需要将其取绝对值,但超过了 int 的表示范围,但由于 int 的上溢处理方法实际上是对值的循环, 所以虽然对 int 赋值 $2^{wordsize-1}$ ,但实际上 int 的取值则是 $-2^{wordsize-1}$, 所以对其求余,实际上是一个负数所以有误.