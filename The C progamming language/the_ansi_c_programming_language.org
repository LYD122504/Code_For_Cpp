                                                                                                                                       :PROPERTIES:
:ID:       7ebcc3c9-fb72-4b14-9adc-374cf47f68b6
:END:
#+title: The ANSI C programming language
#+SETUPFILE:  ../00-latex-preamble.org
#+OPTIONS: tex:imagemagick
 #+FILETAGS: computer
- tag ::
* 位运算操作符(2.9 Bitwise Operators)
在C语言中提供了六种位运算操作符, 分别为: 按位取与(&), 按位取或(|), 按位取异或(^), 按位左移(<<), 按位右移(>>)和按位取反(~). 值得注意的是这些操作符只能用于操作整数的数据类型,不论其是有符号整数还是无符号整数. 进一步, 整数类型的数据类型为 char, short, int 和 long (根据在计算机内占据的字节多少排序). 至于浮点数, 由于位运算会直接操作二进制位, 因此可能会对浮点数的值造成难以预知的结果, 因此从语法层面直接禁止了对浮点数的位运算操作.
** 位运算操作符的含义
*** 按位取与(&)
按位取与是将两个操作数的每位二进制互相进行取与操作, 如果两个操作数的对应位都为1, 那么结果的对应位为1, 否则为0. 例如: 1010 & 1100 = 1000. 值得注意的是, 按位取与大部分的用处实际上将某些位取0. 例如, 如果我们希望将某个数n的后7项保持不变, 其他位取0, 那么我们可以用按位取与完成这个操作
#+BEGIN_SRC C++
//将n的后7位保持不变, 其他位取0
  n&0177
#+END_SRC
这里面我们用到了八进制的表示方法, 即以0开头的数字表示八进制数. 所以0177实际上在二进制上就是0000000001111111, 也就是后7位为1, 其他位为0. 因为任意数与0取与都是0,所以我们可以用这个把想要的位置置0.

小结一下, 按位取与的用途主要是将某些位取0, 保留某些位.
 *** 按位取或(|)
按位取或是将两个操作数的每位二进制互相进行取或操作, 如果两个操作数的对应位有一个为1, 那么结果的对应位为1, 否则为0. 例如: 1010 | 1100 = 1110. 因此, 按位取或的主要用途是将某些指定位置置1, 并保留其他位置的值不变. 例如, 如果我们希望将某个数的从右数第七位置为1, 其他位保持不变, 那么我们可以用按位取或完成这个操作.
#+BEGIN_SRC C++
//将n的第7位置1, 其他位保持不变
  n|0100
#+END_SRC
*** 按位取异或(^)
按位取异或是如果两个操作数的对应位取值不同, 那么结果对应位就为1, 反之则为0. 例如, 1010^1100=0110.
*** 按位左移(<<)和按位右移(>>)
按位左移和右移操作是将左操作数的二进制位向左或向右移动右操作数指定的位数. 因此, 右操作数必须是一个非负整数. 例如, x<<2将x的二进制位整体向左移动两位, 并且在右边补0,这一操作的结果实际上是等价于对x乘4.但是右移操作并不能这么简单的总结, 因为右移操作会导致二进制高位的空缺, 因此如果我们考虑无符号整数的右移操作, 我们将二进制高位补0; 而如果我们考虑的是有符号整数的右移操作, 那就要与具体的底层代码实现有关:有的编译器会以符号位填补高位(算术移位), 有的编译器则会用0填补高位(逻辑移位).
*** 按位取反(~)
与前面的几个操作符不同的是, 按位取反是一元操作符. 按位取反是将操作数的每一位取反, 即0变为1, 1变为0. 例如, ~1010=0101. 我们在按位取与中提到了将n的后几位保持不变, 其余位取0, 在此我们将用按位取与和按位取反来实现, 将n的后七位取0, 其余位保持不变:
#+BEGIN_SRC C++
//将n的后7位取0, 其余位保持不变
  n&~0177
#+END_SRC
值得注意的是, 我们当然可以用 x&0177700 来实现这个操作, 但这其实相当于我们假定了x的位数就是16位, 显然这不适合代码的可移植性.
** getbits 函数的设计思路与代码
*** getbits 函数功能
getbits 函数的形式为
#+BEGIN_SRC C++
unsigned int getbits(unsigned int x,int p,int n)
#+END_SRC
返回无条件整数x二进制形式从右边数第p位开始向右数n位的字段对应的unsigned int形式. 这里我们假设右边的第一位是第0位,n和p是合理的正值,输入错误处理暂时不考虑.
 *** getbits 函数设计思路
因为我们需要从右边数第p位开始向右数n位的字段,所以这个字段最右边其实是第p+1-n位,因此我们需要将这个字段移动到最右边,我们可以用按位右移的方式将其移动到最右端,
#+BEGIN_SRC C++
  x>>=(p+1-n);
#+END_SRC
接下来,我们需要导出最右边的n个字段,也就是相当于保持最右边n位不变,其余位置0即可.从前面的操作符,我们知道, 我们只需要让前面得到的结果和后n位为1, 其余位为0的数按位取与即可. 因此我们关注点就在于如何生成这个后n位为1, 其余位为0; 如果我们考虑将这个数取反, 那么我们只需要去构造后n位为0, 高位为1; 显然这个结果我们可以通过按位左移全1的数得到,所以我们将这个过程转换成代码得到
#+BEGIN_SRC C++
  unsigned int y=~0;
  y<<=n;
  y=~y;
#+END_SRC
        *** getbits 函数代码
Version 1
#+BEGIN_SRC C++
  unsigned int getbits(unsigned int x,int p,int n)
  {
    x>>=(p+1-n);
    unsigned int y=~0;
    y<<=n;
    y=~y;
    return x&y;
  }
#+END_SRC
我们用操作符的优先级将上面的代码写的更加简洁得到Version2
#+BEGIN_SRC C++
  unsigned int getbits(unsigned int x,int p,int n)
  {
    return (x>>(p+1-n))&(~(~0<<n));
  }
#+END_SRC
 ** Exercise 2-6
Exercise 2-6. Write a function setbits(x,p,n,y) that returns x with the n bits that begin at position p set to the rightmost n bits of y, leaving the other bits unchanged
*** 函数设计思路
这个函数是要将x的中间一部分字段替换成y最右边的部分字段, 因此我们需要将y最右边的部分字段提取出来,然后向左移动到对应的位置,
#+BEGIN_SRC C++
  unsigned int y1=y&(~(~0<<n));
  y1<<=(p+1-n);
#+END_SRC
值得注意的是, 这里的y1只有中间一段是y最右边的部分字段, 其余为全是0, 然而我们需要用这个来覆盖掉x对应位置的字段, 保持其余位不变. 因此我们可以用按位取或来完成这个操作, 但值得注意的是这里我们是需要将x相应位置的字段置0. 这样我们就可以将x的相应位置的字段被y1覆盖,其余位不变.
#+BEGIN_SRC C++
  //这一步是为了生成长为n的全1的字段数,其余数为0
  unsigned int x1=((int)pow(2,n) - 1);
  //左移p+1-n位,将其移动到对应的位置
  x1<<=(p+1-n);
  //x1此时是对应位置全1,其余位置为0,我们将其取反,得到对应位置全0,其余位置全1
  x1=~x1;
  //最后我们将x相应的字段置0,其余位置保持不变
  x&=x1;
#+END_SRC
*** 代码实现
#+BEGIN_SRC C++
unsigned setbits(unsigned x, int p, int n, unsigned y)
{
	return ((y & ~(~0 << n)) << (p + 1 - n)) | (x & ~(((int)pow(2,n) - 1) << (p + 1 - n)));
}
#+END_SRC
 ** Exercise 2-7
Write a function invert(x,p,n) that returns x with the n bits that begin at position p inverted (i.e., 1 changed into 0 and vice versa), leaving the others unchanged
*** 函数设计思路
 我们的思路其实就是先将x的指定字段提取出来, 然后只对这一部分取反,再重新取代x相应位置的字段即可. 第一步, 提取x的指定字段, 我们已在getbits函数给出了; 接下来, 我们假设取出来的字段为y, 接下来我们需要对y的字段取反, 但是值得注意的是我们不能将y的高位取反, 换言之, 我们只改变y的右边n位二进制的值, 我们用按位取异或的方式来处理.
 #+BEGIN_SRC C++
   y=y^((int)pow(2,n)-1);
 #+END_SRC
 最后我们就回归了2-6的问题.
*** 代码实现
#+BEGIN_SRC C++
  unsigned int invert(unsigned int x, int p, int n)
  {
    //将x的指定字段提取出来
    unsigned int temp=(x>>(p+1-n))&~(~0<<n);
    //将temp最右边n位数取反
    temp^=((int)pow(2,n)-1);
    //将temp重新取代x相应位置的字段
    return (temp<<(p+1-n))|(x&~(((int)pow(2,n)-1)<<(p+1-n)));
  }
#+END_SRC
** Exercise 2-8
Write a function rightrot(x,n) that returns the value of the integer x rotated to the right by n positions.
*** 函数设计思路
两个思路：
1. 用循环的方式, 每次我们都将x的最右边的一位取出来，然后将x右移一位, 将取出来的位放到最左边, 重复n次即可. 因为这些技术细节其实都在前面解释过了, 这里我们就不去解释了.
2. 这一种则是,我直接一次性将x的最右边n位取出来, 然后将x右移n位, 将取出来的n位放到最左边即可.
但是这两个方法有一个问题,就是我们必须知道x本身在计算机占用的位数, 不然的话, 我们没法移动到合适的位置. 但我们可以通过按位右移的方式来解决这个问题, 假设x占用了4个二进制位, 我们将其按位右移四次, 那么x就变成了0, 因此我们就得到了x的位数
*** 代码实现
思路一
#+BEGIN_SRC C++
unsigned rightrot(unsigned x, int n)
{
	int length = len(x);
	for (int i = 1; i <= n; i++)
	{
		unsigned temp = (x & 1) << (length - 1);
		x = (x>>1) | temp;
	}
	return x;
}
#+END_SRC
思路二
#+BEGIN_SRC C++
unsigned rightrot(unsigned x, int n)
{
	int length = len(x);
	unsigned int temp=x&~(~0<<n);
	x=x>>n;
	temp=temp<<(length-n);
	x=x|temp;
	return x;
}
#+END_SRC
获得x的位数的函数程序
#+BEGIN_SRC C++
int len(unsigned x)
{
	int i = 0;
	for (; x != 0; x >>=1)i++;
	return i;
}
#+END_SRC
* 模式匹配算法 (4.1 Basics of Functions)
在C语言程序设计这本书的第四章中提到了strindex 函数的编写; 其针对的问题是如何在主串(文本串)中找到某种类型的子串, 也就是我们常说的字符串匹配问题. 显然这个方法是存在朴素求解算法的, 在此我们将介绍除朴素求解算法以外的, 另一种优化的匹配算法, 即 KMP 算法和 KMP 算法的两种不同的实现思路.
** 暴力搜索法 (Brute Force)
*** 算法思想
对于文本串 T 和模式串 P, 从文本串的第一个字符与模式串的第一个字符开始匹配; 如果相等, 那么比较位置同时后移, 比较第二个字符是否匹配, 以此类推; 直到出现模式串结束, 那么输出文本串的位置; 或者出现有一个不匹配的字符, 那么将文本串回退到最早比较的下一个字符, 模式串回退到开始, 重新循环.
*** 算法实现
#+begin_src C
int strindex(char* text,char* pattern)
{
  int i,j,k;
  for(i=0;s[i]!='\0';i++)//文本串的循环
    {
      for(k=i,j=0;pattern[j]!='\0'&&pattern[j]==text[k];j++,k++)
          //模式串的循环
	;
    if(j>0&&pattern[j]=='\0')//判断是否为真正匹配结束
      return i;
    }
  return -1;
}
#+end_src
*** 算法分析
我们假设文本串的长度为 $n$, 模式串的长度为 $m$

最坏的情况是类似于文本串为AAAAAAAB, 模式串为AAAB,这样的话, 需要匹配 $(n-m+1)m$ 次, 时间复杂度为 $O(nm)$.

最好的情况则是第一次匹配就成功, 那么时间复杂度就是 $O(m)$.

如果我们考虑每种情况以等概率的情况出现, 我们可知 BF 算法的平均时间复杂度为 $O(nm)$.
** KMP 算法
我们在上面发现对于文本串为AAAAAAAB, 模式串为AAAB的匹配, 每次都是在最后一个字母匹配出错, 然后就要将模式串和文本串同时回退, 重新比较; 这一步会消耗大量的时间, 并且完全没有利用到前面匹配的结果; 因此KMP算法的提出就是为了解决上面提到的问题: 其利用了匹配失败以前的匹配成功的结果, 从而将时间复杂度降到了 $O(n+m)$.
*** KMP 算法的基本思想
其核心思想就是当出现不匹配的情况, 利用已知匹配的结果避免回退文本串的指针并且尽可能少的回退模式串的指针.

例如, 如果我们匹配到第 $j$ 个字符串出现了字符不匹配现象, 那么我们已知的是 $P[0:j-1]=T[i:i+j-1]$, BF 算法对这个的处理是直接回退文本指针和模式指针, 并不利用这一良好性质. 而 KMP 算法则是需要寻找 $P[0:j-1]$ 的最长相等前后缀,因为已知 $P[0:j-1]=T[i:i+j-1]$; 假设 $P[0:j-1]$ 的最长相等前后缀长度为 $k$,那么你就可以通过一个连等式快速得到需要回退的位置, 即 $P[0:k-1]=P[j-k:j-1]=T[j-k:j-1]$; 如此可知实际上, 即使我们用暴力搜索重新去计算, 只不过是不断地失败, 直到达到上面所说的情况而已.
*** 基于 PMT 的 KMP 算法
上面介绍了 KMP 算法的基本思想, 接下来我们就用不同的实现思路去实现 KMP 算法的思想. 首先我们引入 PMT (Partial Match Table, 部分匹配表) 的概念, 其实这个表就是将要介绍的前缀表.
**** 前缀表的定义
前缀表在 KMP 算法中的作用是用来控制模式指针的回退, 其记录的是字符串的最长相等前后缀的长度, 其用于寻找当出现模式串与文本串不匹配的时候, 模式串应该从哪里开始重新匹配.

例如对于文本串 T=aabaacaabaaf, 模式串为 P=aabaaf; 在第一次字符串匹配时, $P[5]$ 和 $T[5]$ 不匹配了, 如果用 BF 算法, 那么我们下一次匹配就是 $P[0]$ 和 $T[1]$ 的比较; 但显然我们通过朴素的思考, 因为 $P[0:4]$ =aabaa 的最长相同前后缀为 aa, 所以利用 KMP 算法的下一次匹配实际上是考虑 $P[2]$ 和 $T[5]$ 的匹配, 显然如此, 匹配速度有很大的提升.

前缀表是记录下标 i 之前 (包括 i) 的字符串中的最长相同前后缀的长度.

对于一个字符串的前缀指的是包含首字符, 但不包含尾字符的字符串; 例如 aabaaf 的前缀集合为 {a,aa,aab,aaba,aabaa}

对于一个字符串的后缀指的是包含尾字符, 但不包含首字符的字符串; 例如 aabaaf的后缀集合为 {f,af,aaf,baaf,abaaf}

**** 前缀表的计算思路及代码实现
1. 引入两个指针 i 和 j; j 用来指示前缀的末尾, i 用来指示后缀的末尾; 换言之, i 会从 0 开始遍历模式串的每一个下标, j 则是用于记录 P[0:i-1] 的最长相等前后缀的长度.
2. 如果模式串的第 i 位和模式串的第 j 位相等, 那么 j++, i++即可
3. 如果模式串的第 i 位和模式串的第 j 位不相等, 那么就要做一个持续回退; 因为已知 P[j]!=P[i], 但是 P[0:j-1]=P[i-j:i-1]; 那么我们可以用 j=pmt[j-1] 来回退到 P[0:j-1] 的最长相等前后缀的后一位; 这一步的依据是首先 P[0:j-1]=P[i-j:i-1], 并且我们假设 k 为 P[0:j-1] 的最长相等前后缀长度, 那么 P[0:k-1]=P[j-k:j-1]=P[i-k:i-1], 如此就可以去比较 P[k] 和 P[i].
4. 更新 pmt 数组

代码实现如下:
#+BEGIN_SRC C
  void generate_PMT(const string &pattern,int* pmt)
{
    int j=0;
    pmt[0]=0;
    for(int i=1;i<pattern.size();i++)
    {
        while(j>0&&pattern[i]!=pattern[j])
            j=pmt[j-1];
        if (pattern[i]==pattern[j])
            j++;
        pmt[i]=j;
    }
}
#+END_SRC

利用前缀表进行 KMP 算法匹配思路
1. 设置两个指针 i 和 j; i 用来控制在文本串的移动; j 用来控制在模式串的移动
2. 如果匹配没出错, 那么返回匹配的起点即可
3. 如果匹配出错了, 那么分情况讨论,如果 j=0, 即模式串的第一个字符就与其不匹配, 那么就需要将文本串向后移动一位; 如果 j 不为0, 那么就用 j=pmt[j-1] 去更新匹配成功部分的最长相等前后缀.
4. 输出结果
 **** 利用前缀表进行 KMP 算法代码实现
#+BEGIN_SRC C
  void generate_PMT(const string &pattern,int* pmt)
{
    int j=0;
    pmt[0]=0;
    for(int i=1;i<pattern.size();i++)
    {
        while(j>0&&pattern[i]!=pattern[j])
            j=pmt[j-1];
        if (pattern[i]==pattern[j])
            j++;
        pmt[i]=j;
    }
}
  int strindex(string text,string pattern)
{
    int j=0;
  	if (text.size()==0)
        return -1;
    if (pattern.size()==0)
        return 0;
    vector<int> pmt(pattern.size());
    generate_PMT(pattern,&pmt[0]);//&取地址
    for(int i=0;i<text.size();i++)
    {
        while(j>0&&text[i]!=pattern[j])
            j=pmt[j-1];
        if(text[i]==pattern[j])
            j++;
        if(j==pattern.size())
            return (i-pattern.size()+1);
    }
    return -1;
}
#+END_SRC
**** 用 next 数组实现 KMP 算法
我们在此额外介绍前缀表的另一种表示形式, 也就是 next 数组, 在市面上很多算法书更多采用这种. 我们只介绍其中一种 next 数组生成方法, 也就是将前缀表整体右移以后, 在第一个位置补上 -1. 我们给出代码实现.
#+BEGIN_SRC C
  void generate_NEXT(const string& pattern, int* next)
{
    int j = -1;
    next[0] = -1;
    for (int i = 1; i < pattern.size(); i++)
    {
        while(j>=0&&pattern[i-1]!=pattern[j])
			j=next[j];
        if (j == -1 || pattern[i-1] == pattern[j])
            next[i] = ++j;
    }
}
int strindex(string text,string pattern)
{
    int j=0;
    if (text.size()==0)
        return -1;
    if (pattern.size()==0)
        return 0;
    vector<int> next(pattern.size());
    generate_NEXT(pattern,&next[0]);//&取地址
    for(int i=0;i<text.size();i++)
    {
        while(j>0&&text[i]!=pattern[j])
            j=next[j];
        if(j==-1||text[i]==pattern[j])
            j++;
        if(j==pattern.size())
            return (i-pattern.size()+1);
    }
    return -1;
}
#+END_SRC
** 基于 DFA 的 KMP 算法
*** DFA 的定义
自动机分为两类: DFA (确定性有限状态自动机) 和 NFA (非确定性有限状态自动机), 二者均可用于字符串匹配问题, 我们在此仅使用 DFA 来完成 KMP 算法. 而 NFA 主要用于正则表达式的匹配问题.

#+DOWNLOADED: screenshot @ 2024-12-15 17:00:22
[[file:img/KMP_算法/2024-12-15_17-00-22_screenshot.png]]

由上图知, DFA 由状态 (带数字的圆圈) 和转换 (带模式串字母的箭头) 组成. 从上图知, 由于模式串为 ABABAC 六个字符, 因此 DFA 一共由七个状态, 其中状态 0 表示起始状态, 也就是未开始匹配的状态, 模式 6 为匹配成功的状态. 值得注意的是, 构建的 DFA 是基于模式串进行的, 文本串是一系列输入该 DFA 的参数; 从某种角度来说, 这与我们前面提到的 next 数组类似, 实际上这两个只是不同维度的同一内容而已.

进一步, 我们给出图中涉及的一些专业术语, 在字符串匹配问题上, 每个状态都表示模式串中各个字符串的索引值, 该图中给出了在每个状态下输入不同字符的状态的转换操作, 但实际上这些转换中只有 0-1-2-3-4-5-6 这一条是匹配转换(其实就是从第 i 个状态转换到第 i+1 个状态), 其余的转换操作都需要回退指针, 称之为非匹配转换.
**** 构建 DFA 的思路与算法实现
在计算机内部, 我们用二维数组 DFA[char][state] 来表示上面介绍的 DFA, 其中 DFA[i][j] 具体含义是在状态 j 的情况下输入字符 i 之后, 状态转换的结果.

从构建DFA的流程中, 我们知道 DFA 的状态转换只有两种类型: 匹配转换或者非匹配转换.对此分类讨论即可得到构建 DFA 的算法

如果状态转换是匹配转换, 也就是在第 j 个状态下输入的字符是 pattern[j], 那么匹配成功, 我们可以转换到第 j+1 个状态, DFA[pattern[j]][j]=j+1;

假如状态转换是非匹配转换, 也就是在第 j 个状态下输入的字符并不是 pattern[j]. 为了后续讨论简便, 我们用 i 来表示输入的文本串字符位置, 但是 text[i] 不等于 pattern[j]. 此时, 因为出现了匹配失败的情况, 我们需要回退状态, 但是我们尽量要避免和暴力算法一样直接回退到开始, 而是尽可能少的回退, 并且不排除任何可能情况, 这就是 KMP 算法本身的思想. 虽然我们在第 j 个状态下匹配失败, 但是我们已知 Pattern[0~j-1] 和 text[i-j~i-1] 已经完成了匹配. 所以无论如何从 text[i-j] 开始去寻找模式串已经是不可能成立的了, 所以此时我们就可以从 text[i-j+1]开始分析, 如果我们输入的新字符串是 text[i-j+1~i-1], 那么会出现在什么状态? 由于这个新字符串依赖的不仅仅是文本串的内容, 实际上由于 Pattern[0~j-1]=text[i-j~i-1], 我们可以认为输入的新字符串实际上是 Pattern[1~j-1]. 所以我们就得到了一系列等价表达, 即如果在第 j 个状态下输入的 text[i] 出现了非匹配转换, 其最终状态等价于输入text[i-j+1~i-1]以后再输入 text[i] 的状态,等价于输入 Pattern[1~j-1] 以后再输入 text[i] 的状态. 

此时会发现如果我们要知道第 j 个状态下的非匹配转换结果, 其实我们只需要知道 输入 Pattern[1~j-1] 之后的状态; 由于我们的 DFA 构造是递推的, 所以这个状态的转换结果是已经构造了的, 我们可以直接得到这个结果, 换言之其实是一个 DP 过程. 为了讲解方便, 我们引入一个重启状态的概念, 重启状态就是如果我们在第 j 个状态下出现了非匹配转换, 那么由我们前面的讨论得知, 输入 Pattern[1~j-1] 得到的状态就是第 j 个状态的重启状态, 第 j 个状态的非匹配转换和重启状态的对应字符转换状态一致. 

我们给出如下的例子来解释重启状态, 在上面的 DFA 的图中, 如果我们用 ABABAA 来输入这个 DFA 中, 在状态 5 中, 最后输入的字符是 A, 与 C 不匹配, 那么我们就需要去找这个状态的重启装态, 我们已知 Pattern[0~4]=ABABA, 寻找重启状态的话, 我们就需要输入 Pattern[1~4]=BABA, 通过查图, 我们可以发现状态 5 的非匹配转换和状态 3 的一致. 

为了解释方便, 我们用重启状态数组来加以解释, 虽然我们在代码中是以数的形式存在, 但这并不影响. X[j+1] 表示输入 Pattern[1~j] 之后再输入 Pattern[j+1] 得到的结果, 但是我们知道输入 Pattern[1~j] 得到的状态其实是 X[j], 所以我们要求的 X[j+1] 实际上是在状态 X[j] 的基础上输入 Pattern[j+1] 的状态, 也就是 X[j+1]=DFA[Pattern[j]][X[j]]. 我们初始化 X[0]=0.

下面给出构建 DFA 的代码,

#+BEGIN_SRC C
void generate_DFA(const string& pattern, vector<vector<int>> &DFA)
{
    DFA[pattern[0]][0] = 1;
    int X;
    for (int j = 1, X = 0; j < pattern.size(); j++)
    {
        for (int i = 0; i < 256; i++)// 256是asc码的长度,需要将字符串内出现的所有可能字符都列入
            DFA[i][j] = DFA[i][X];
        DFA[pattern[j]][j] = j + 1;
        X = DFA[pattern[j]][X];
    }
}
#+END_SRC
其实, 在 DFA 中寻找重启状态, 我们用的是 Pattern[1~j-1] 重新输入, 这个其实就是我们在 PMT 中寻找最长相等前后缀的过程, 只是 DFA 将其可视化了而已, 或者说, 我们在前面构造的重启状态数组实际上就是 PMT. 因此这两个办法理论上没有任何区别, 不过 DFA 在空间存储方面消耗更大, 他是一个二维数组.
*** 用 DFA 实现 KMP 的算法实现
如果我们已经构造了 DFA 数组, 我们只需要存储对应状态和依次输入文本串到 DFA 即可. 值得注意的是, 循环结束的原因是

1. 达到匹配成功状态, 返回文本串匹配成功起点
2. 文本串达到末尾, 也就是匹配失败, 返回 -1
   #+BEGIN_SRC C
void generate_DFA(const string& pattern, vector<vector<int>> &DFA)
{
    DFA[pattern[0]][0] = 1;
    int X;
    for (int j = 1, X = 0; j < pattern.size(); j++)
    {
        for (int i = 0; i < 256; i++)
            DFA[i][j] = DFA[i][X];
        DFA[pattern[j]][j] = j + 1;
        X = DFA[pattern[j]][X];
    }
}
int strindex(string text, string pattern)
{
    const int R = 256;
    vector<vector<int>> DFA(R, vector<int>(pattern.size(), 0));
    generate_DFA(pattern, DFA);
    int i, j;
    for (i = 0, j = 0; i < text.size() && j < pattern.size(); i++)
    {
        j = DFA[text[i]][j];
    }
    if (j == pattern.size())
        return i - pattern.size();
    else return -1;
}
   #+END_SRC
*** KMP 算法分析

如果模式串长度为 $m$, 文本串长度为 $n$.

空间复杂度显然是 $O(m)$

对于时间复杂度分析, 我们只考虑 PMT 的情况, DFA 完全类似. 由于 PMT 需要求解 PMT 数组/Next 数组和 KMP 搜索两部分代码, 所以我们逐步分析.

1. 求解 PMT 数组/ Next 数组; 外层的 for 循环需要迭代 $m-1$ 次, 但是里面嵌套了一个 while 循环, 如果我们试图直接寻找 while 的循环次数, 虽然可以得到结果, 但是显然不太现实. 我们利用 j 的值的变化来近似分析时间复杂度. j 的变化只有两种情况, 要么加一, 要么 j=pmt[j-1] 减少. 但是减少的程度其实依赖于 j++ 的程度, 而 j++ 和 i++ 都是同时发生的, 所以最多发生 $m-1$ 次, 因此这一步的时间复杂度是 $O(m)$
2. 搜索: for 循环走的次数是 $n-1$, while 的回退其实总体来说最多只可能走 $n-m$ 因此一共复杂度 $O(n+m)$

* Extern, Const和Static 的用法 (4.3-4.4)
** Extern 的用法
在 C 语言中, 修饰符 extern 用在变量或者函数声明之前, 用来标识变量或者函数的定义在别的文件中已经给出, 告知编译器运行到此变量或函数时, 在其他位置寻找其定义. 其常见的用法如下:
#+BEGIN_SRC C++
extern int a;
extern int b;
int max(int l,int r) {
    return l > r ? l : r;
}
int main() {
    cout << max(a, b) << endl;
}
int a = 10;
int b = 20;
#+END_SRC
此处如果不在开头加上 extern int a,那么main函数是无法访问变量 a,b 的, 即使变量 a,b 是一个外部变量, 但其作用域是定义以后至程序结束, 而修饰符 extern 引导的变量声明延拓了该外部变量的存在域. 实际上, extern 修饰符主要还是在多源文件的情况下使用.
*** Extern 修饰变量的声明
extern关键字可以用来修饰变量，表示该变量在别的文件中已有声明。例如：我们在文件file1.c中声明了变量int var，然后我们又需要再file2.c中使用该变量，则可在文件file2.c中声明extern int var，就可在文件file2.c中使用该变量了。

值得强调的是 extern 修饰的是变量的声明, 变量的声明仅仅向编译器传递了变量的信息, 但并不会分配内存; 分配内存是通过变量定义来实现的. 因此我们如果使用 extern 修饰变量声明, 是不可以同时在其后初始化, 因为声明并不会对变量, 对内存操作的. 其次, 使用 extern 修饰声明的变量一定要是全局变量, 这是因为如果声明的是局部变量, 那么他的存活域只在某个函数体内部, 在其他文件中引用这个变量也是没有意义的.

进一步, 我们可以讨论由 extern 修饰的变量声明对应的存活域. 首先, 由前面的介绍知道, extern 声明的变量只能是全局变量, 但是如果 extern 修饰的变量声明位于某个函数体内, 那么其存活域也只在这个函数内部, 与在函数内部设置的局部变量一致.
*** Extern 修饰函数声明
从本质来看, extern 修饰函数声明与修饰变量声明是等价的. 但我们更为常用的引用其他文件的函数是通过头文件的方式来引用的. 在程序实现层面, 这两种方式是有所不同的, 引用头文件的编译处理是一种预处理方式, 而extern 修饰的声明则是代码链接层面的实现. 因此一般而言, 如果需要大批量引用函数声明, 那么就用头文件更为便利, 而如果只是引用少数函数, 那么用 extern 修饰声明即可.
               *** Extern 用来实现链接指定
extern用来进行链接指定一般来说是用来实现混合编程. 例如我们如果要在C++程序中调用C代码, 那么我们就需要用extern "C"来声明.

extern "C" 可用于单一语句
#+BEGIN_SRC C
  extern “C” double sqrt(double);
#+END_SRC
也可以是复合语句, 相当于复合语句中的声明都加了 extern “C”
#+BEGIN_SRC C++
  extern “C”
{
      double sqrt(double);
      int min(int, int);
}
#+END_SRC
同样可以包含头文件，相当于头文件中的声明都加了extern “C” (不建议这样写，会有嵌套可能)
#+BEGIN_SRC C
extern “C”
{
      #include <cmath>
}
#+END_SRC
值得注意的是, extern "C" 是不可以用在函数内部的, 且如果函数有多个声明, 可以全都加上 extern "C", 也可以只加一个, 后续声明会遵循第一个链接指示符的规则.
** Static 的用法
static 的用法其实只有三个: 隐藏, 保持变量持久, 默认初始化为0
*** Static 的主要功能:隐藏
当我们同时编译多个源文件时, 普通的全局变量和函数 (即未加 static 的) 都是全局可访问的.

例如, 对于多源文件main.cpp和test.cpp如下所示
#+BEGIN_SRC C++
//main source
#include<stdio.h>
int main(void)
{
    extern char a;    // extern variable must be declared before use
    printf("%c ", a);
    extern void msg();
    msg();
    return 0;
}
#+END_SRC
test.cpp结构如下
#+BEGIN_SRC C++
#include<stdio.h>
char a = 'A'; // global variable
void msg()
{
    printf("Hello\n");
}
#+END_SRC
上述可以运行是因为在test.cpp文件中的全局变量并没有加static,因此其余文件可以随意的利用修饰符extern来调用全局变量和函数. 如果加上static, 那么他就会对其余的源文件隐藏, 只能在本文件中使用. 因此利用这一特性我们可以在不同的源文件定义同名变量与同名函数, 不会出现命名冲突, 也不会出现数据混用的情况. static 可用于修饰函数也可以用来修饰变量; 如果针对函数, 那么 static 的作用仅限于隐藏; 而对于变量, 那么 static 就有接下来的两个作用.
*** 保持变量内容的持久
与自动变量存储在栈区不同, static变量会存储在静态存储区. 虽然全局变量也会存储在静态存储区, 但是与全局变量相比, static变量主要的特性是对变量的隐藏. 

如果static用于声明内部变量, 那么static类型的内部变量和函数内部的自动变量一样,只能在函数内部使用, 但不同的一点是, 函数内部的自动变量会在函数运行结束自动释放内存, 下一次运行需要重新声明, 重新分配内存; 而static类型变量则不会, 她只在第一次声明时分配内存且完成初始化, 不会随着函数的返回而释放空间, 一直等到重新调用函数时,其值为上次结束时的值.

#+BEGIN_SRC C++
#include <stdio.h>
int fun(void){
    static int count = 10;    // 首次运行时,会将静态变量完成初始化,而后不会再运行,下一次的值是由上次存储的数据来保证.
    return count--;
}
int count = 1;
int main(void)
{    
    printf("global\t\tlocal static\n");
    for(; count <= 10; ++count)
        printf("%d\t\t%d\n", count, fun());    
    
    return 0;
}
#+END_SRC
*** 默认初始化为 0
实际上, 全局变量也有这个特性, 这是因为全局变量和静态变量都存储在静态存储区, 静态存储区的字节默认为 0x00. 善用这个特性, 可以极大简便程序的编写复杂度, 如果我们考虑一个稀疏矩阵, 如果我们设置局部变量, 那么我们需要先将变量全部置为0, 而后一个个添加非零元素; 实际上我们可以直接用静态变量, 这样的话, 我们只需要添加非零元素即可. 这同样对字符串有相同的操作.
** Const 的用法
const 用来修饰一个变量, 那么他的值从某种角度来说就是不能被改变的. 这其实很类似与C语言中的#define的宏命令, 这两个之间还是有较大的差异:

1. #define 是预处理指令, 其在预处理阶段就会完成文本替换. 而const则是对变量的修饰,因此他需要在后续的语法编译的时期, 程序还要检查其类型是否正确, 对比更加安全.
2. const 可以保护被修饰的内容, 防止意外修改, 从而来增强程序的鲁棒性.
3. const 常量是不通过编译器分配内存空间的, 而是将其纳入符号表; 这样使得他在运行过程中不需要存储和读取内存的时间, 提高了运行效率.
*** 修饰局部变量
#+BEGIN_SRC C++
const int a=1;
int const a=1;
#+END_SRC
这两个语句表示的是同一条命令, 即定义整型const常量a并初始化为1. 由于const常量后续将不再允许被修改, 因此我们在定义const常量的同时一定要对其进行初始化. 其实对于这种基本类型的const修饰十分简单, 我们考虑const字符串,可以知道他的一些优势.
#+BEGIN_SRC C++
const char* ptr="Hello world!";
#+END_SRC
如果这里我们不加上const限定符, 那在程序中可能出现 ptr[3]='L' 的命令, 他会因为对只读区域的写入而报错, 也就是在程序运行时报错; 而如果我们用 const 限制符, 那么在程序编译期间, 就会因为试图修改const常量而报错.
*** 常量指针和指针常量
值得注意的是 const 的使用在此处将会十分灵活, 因为他涉及到指针的内容, 因此比较复杂.

首先, 我们先考虑常量指针, 其声明方式如下所示,
#+BEGIN_SRC C++
const int* ptr;
int const * ptr;
#+END_SRC
常量指针的含义为指针指向的内容是常量. 不可以通过常量指针来修改对应的值. 需要注意的是,

1. 这里的常量指针不能修改对应的值,只是不能通过常量指针修改; 但允许通过其他的引用来修改, 例如
   #+BEGIN_SRC C++
     int a=10;
     const int* pn=&a;
     ,*pn=10; //报错,因为pn是常量指针
     a=10; //允许运行, 因为这是其他的引用并没有常量的限制
   #+END_SRC
 2. 常量指针指向的值不能修改, 但是可以修改常量指针指向的对象, 也就是可以将常量指针指向不同的位置.
    #+BEGIN_SRC C++
      int x=5;
      int y=6;
      const int* pn=&x;
      pn=&y;
    #+END_SRC
其次, 我们讨论指针常量, 其定义声明如下所示
#+BEGIN_SRC C++
int* const pn;
#+END_SRC
指针常量指的是这个指针本身就是一个常量, 我们在运行过程中不可以重新给该指针常量重新赋值, 但是我们可以用这个指针修改他指向的内容. 例如
#+BEGIN_SRC C++
int a = 5;
int* const n = &a;
*n = 10;
#+END_SRC
这两种const常量的定义的区别仅在于 const 限定符与 * 的位置关系, 如果const在* 左边, 那么定义的就是常量指针; 如果const在* 右边, 那么定义的就是指针常量. 特殊的实际上, 我们可以将上面的两种定义合并, 得到指向常量的常指针的定义
#+BEGIN_SRC C++
const int* const a=10;
#+END_SRC
指针指向的位置不能改变并且也不能通过这个指针改变变量的值，但是依然可以通过其他的普通指针改变变量的值.
*** 修饰函数的参数
根据前面讨论的常量指针和指针常量, const修饰函数的参数也为两种

1. 防止修改指针指向的内容
   #+BEGIN_SRC C++
     void StringCopy(char *strDestination, const char *strSource);
   #+END_SRC
2. 防止修改指针的地址
   #+BEGIN_SRC C++
     void swap(int* const p1, int* const p2);
   #+END_SRC
   不能随意修改p1和p2的地址.
*** 修饰函数的返回值
如果给以“指针传递”方式的函数返回值加 const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针.
#+BEGIN_SRC C++
const char* Getstring();
const char* str=Getstring();
#+END_SRC
*** 修饰全局变量
全局变量的作用域是整个文件，我们应该尽量避免使用全局变量，因为一旦有一个函数改变了全局变量的值，它也会影响到其他引用这个变量的函数，导致除了bug后很难发现，如果一定要用全局变量，我们应该尽量的使用const修饰符进行修饰，这样防止不必要的人为修改，使用的方法与局部变量是相同的。
** 代码运行的内存分配
C/C++程序经过编译器完成编译链接等等处理工作以后得到的二进制文件, 其包含栈(stack), 堆(heap), 数据段, BSS段, 代码段. 其中数据段, BSS段和代码段是程序编译完成就已经分配完成了, 无需等代码运行; 而堆区和栈区需要程序被加载到内存开始运行时才会分配.

1. 栈区(stack): 由编译器自动分配和释放内存. 该区一般用于存储函数参数, 局部变量等值. 其操作方式类似于数据结构中提到的栈.

2. 堆区(heap): 程序员通过 new 命令和 malloc 命令, 可以动态申请某个大小的内存. 注意的是, 此区的内存和栈区的不同, 并不能由编译器自动释放, 而是由程序员通过 delete 命令和 free 命令来手动释放内存, 如果不释放, 长期使用下, 申请内存超过了堆区大小, 那么就会发生内存泄漏现象. 

3. 数据段: 数据段属于静态内存分配,所有有初值的全局变量和用static修饰的静态变量，常量数据都在数据段中。实际上可以认为其分为两块数据段:1.只读数据段 2. 读写数据段.

   在只读数据段中, 一般用来存储程序使用时不会发生变化的数据.一般是用const修饰的变量或者程序中使用的文字常量存储在此处. 特殊的还有常量存储区（特殊的常量存储区，属于静态存储区）

        1) 常量占用内存,只读状态,决不可修改
        2) 常量字符串就是放在这里的，程序结束后由系统释放

   读写数据段:用来存储那些已经完成初始化的全局变量或者初始化的静态变量. 已初始化数据是在程序中声明，并且具有初值的变量，这些变量需要占用存储器的空间，在程序执行时它们需要位于可读写的内存区域内，并且有初值，以供程序运行时读写

4. BSS段: 存储未初始化的全局变量或者静态（全局）变量. 其是可读写的, 编译器给处理成0. 未初始化数据是在程序中声明, 但是没有初始化的变量, 这些变量在程序运行之前不需要占用存储器的空间. 与读写数据段类似, 它也属于静态数据区. 但是该段中数据没有经过初始化. 未初始化数据段只有在运行的初始化阶段才会产生, 因此它的大小不会影响目标文件的大小.

5. 代码段: 存放函数体的二进制代码,所有语句经过编译后产生的CPU指令都会存放在此处.
* 逆波兰表达式计算器代码(Chapter4)
** 逆波兰表达式
我们使用最为频繁的计算表达式其实是中缀表达式, 也就是操作符在两个操作数之间. 这个的缺点在于, 加减乘除的优先级并不是简单的从左到右计算的, 而是存在一定的优先级. 因此如果我们想要得到想要的结果, 就必须使用括号来辅助我们的计算, 而括号的嵌套则会使计算的复杂度大幅增加. 所以, 我们引入逆波兰表达式, 也就是所谓的后缀表达式, 其特点在于将操作符直接置于操作数之后. 其具体的用法如, $(3-4)*5$ 的逆波兰表达式为 $3 4 - 5 *$; $3-4*5$ 的逆波兰表达式为 $3 4 5 * -$. 逆波兰表达式的优点在于, 他不需要括号, 也不需要考虑优先级, 只需要按照顺序进行计算即可.
** 计算器的设计思路
我们基于前面提到的逆波兰表达式的思想, 我们发现这个流程其实是符合后进先出的原则, 因此我们采用栈的数据结构来实现这个计算器. 具体思路如下: 我们每次从输入缓冲区中读取一个字符, 如果是数字, 那么我们就将其压到栈里; 如果是操作符, 暂时我们只考虑二元操作符, 那么我们就从栈顶弹出两个数进行计算, 如果操作数不够, 就弹出异常报错, 最后我们将计算的结果重新压入栈中. 如果我们在此过程中读取到了结束符, 弹出栈顶元素后, 检查栈是否为空, 如果为空, 那么我们就得到了计算结果, 如果不为空, 那么我们就得到了异常报错.
** 模块实现
我们将上述过程分成三个大模块和一个主函数, 分别是: getop, getch, stack. 
*** stack模块(栈操作模块)
栈从修改的角度来说, 只有两种操作, 一种是压栈(push), 另一个则是弹栈(pop). 我们在此用数组的形式来实现栈, 我们设置一个指标pos作为标注下一个空闲栈的位置. 显然我们的push和pop操作都需要操作栈空间和栈指标, 因此我们在定义栈和指标的时候, 我们需要将其定义为全局变量. 代码如下所示
#+BEGIN_SRC C++
  #include<stdio.h>
  #define MAXVAL 100// maximum depth of val stack
  int sp = 0; // new free stack position
  double val[MAXVAL]; // value stack
  // pop: pop and return top value from stack
  double pop()
  {
    if (sp)
      return val[--sp];
    else
      {
        printf("ERROR: empty stack.\n");
        return 0.0;
      }
  }
  // push: push f onto value stack
  void push(double v)
  {
    if (sp < MAXVAL)
      val[sp++] = v;
    else
      printf("ERROR: stack full, can not push %g\n", v);
  }
#+END_SRC
在这里, 其实我们可以进一步要求sp和val是静态的, 也就是只能在本文件中使用, 这样的话, 会使代码更加安全.
*** getop模块(获取操作数/符模块)
这里我们需要考虑的是, 一个操作数可能是多位数, 也可能是小数; 至于负数, 我们可以用0-x的形式来表示. 其流程如下: 首先我们需要先跳过操作数/符之前的空格或制表符, 然后我们读取一个字符, 判断是不是数字, 如果不是数字部分,我们就将其返回; 如果是数字部分, 那我们将其收集起来并继续读取, 直到一个非数字的字符出现,在此我们又要判断是否是小数点, 如果是小数点, 也就是我们接下来读取小数部分; 反之则是已经读取结束. 值得注意的是, 我们在读取这些的过程经常会出现, 读取了一个字符, 以后发现不是我们想要的, 这时我们需要将其放回缓冲区(我们将会在后面的模块设置), 并不可以直接丢弃.
#+BEGIN_SRC C++
  int getop(char s[])
  {
    int i, c;
    while ((s[0] = c = getch()) == ' ' || c == '\t')
      ;
    s[1] = '\0';
    if (!isdigit(c) && c != '.')
      return c; /* not a number */
    i = 0;
    if (isdigit(c)) /* collect integer part */
      while (isdigit(s[++i] = c = getch()))
        ;
    if (c == '.') /* collect fraction part */
      while (isdigit(s[++i] = c = getch()))
        ;
    s[i] = '\0';
    if (c != EOF)
      ungetch(c);
    return NUMBER;
  }
#+END_SRC
*** getch模块(获取字符模块)
这个模块的作用是从输入缓冲区中读取一个字符, 并返回. 但是我们在这里需要考虑的是, 有时候我们读取了一个字符, 发现不是我们想要的, 那么我们就需要将其放回缓冲区, 以便下次读取.
#+BEGIN_SRC C++
  #include<stdio.h>
  #include<string.h>
  #define BUFSIZE 100
  char buf[BUFSIZE]; /* buffer for ungetch */
  int bufp = 0; /* next free position in buf */
  int getch(void) /* get a (possibly pushed-back) character */
  {	
    if (buf[bufp - 1] == EOF)
      printf("EOF!");
    return (bufp > 0) ? buf[--bufp] : getchar();
  }
  void ungetch(int c) /* push character back on input */
  {
    if (bufp >= BUFSIZE)
      printf("ungetch: too many characters\n");
    else
      buf[bufp++] = c;
  }
#+END_SRC
*** 主函数
在主函数其实我们只需要不断调用getop函数, 并根据返回值的不同来进行不同的操作即可.
#+BEGIN_SRC C++

#include<stdio.h>
#include<stdlib.h>
#include<math.h>

#include "calc.h"
#define exp_tag 'e'
#define sin_tag 'i'
#define VARIABLE 'x'
#define MAXOP 100
#define MAXLINE 1000 // length of a maximum line to be read
//reverse Polish calculator
int main()
{
	int type;
	double op2=0.0;
	char s[MAXOP];
	while ((type = getop(s)) != EOF)
	{
		switch (type)
		{
		case NUMBER:
			v = atof(s);
			push(v);
			break;
		case '+':
			push(pop() + pop());
			break;
		case '*':
			push(pop() * pop());
			break;
		case '-':
			op2 = pop();
			push(pop() - op2);
			break;
		case '/':
			op2 = pop();
			if (op2)
				push(pop() / op2);
			else
				printf("ERROR: zero divisior.\n");
			break;
		case '\n':
			op2 = pop();
			printf("\t%.8g\n", op2);
			break;
		default:
			printf("ERROR: unknown command %s\n", s);
			break;
		}
	}
	return 0;
}
#+END_SRC
这里注意的是, 我们的减法和除法是有顺序的, 也就是我们需要先存储下第一个操作数,等第二个操作数弹出, 再操作, 这样才能保证我们的计算是正确的.
*** 头文件
#+BEGIN_SRC C++
//计算器头文件,用于声明需要的函数
#define NUMBER '0'
// 缓冲区的输入操作
int getch();
void ungetch(int);
//getop 输入字符串
int getop(char s[]);
//栈操作
void push(double);
double pop();
#+END_SRC
** 多文件编译过程
C/C++ 程序执行流程其实是先将源文件编译成中间代码文件, 在windows下是.obj文件, 在linux下是.o文件, 然后再将这些文件链接成可执行文件. 举个例子, 我们如果对上面的代码编译,那么我们需要先对这些文件进行编译,也就是
#+BEGIN_SRC bash
  gcc -c stack.c
  gcc -c getch.c
  gcc -c getop.c
  gcc -c main.c
#+END_SRC
此时,我们会得到四个中间文件, 分别是stack.o, getch.o, getop.o, main.o. 然后我们再将这些文件链接成可执行文件
#+BEGIN_SRC bash
  gcc -o calc stack.o getch.o getop.o main.o
#+END_SRC
但是很显然如此操作, 如果我们修改了一个文件, 我们就要重新走一遍这个流程, 这样的效率是很低的. 因此我们可以使用makefile来自动化这个过程. 我们先给出一个上面的makefile文件的版本
#+BEGIN_SRC makefile
  #version1
  #在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的
  #在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个tab键作为开头。make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。
  #执行命令一定是以一个tab键作为开头的
  maincc:main.o getch.o getop.o stack.o
  g++ main.o getch.o getop.o stack.o -o maincc    #用g++把中间文件链接编译成可执行文件,并且用-o将其命名为maincc
  #这一步是告知计算机main.o文件的生成需要用到main.cpp文件
  main.o:main.cpp
  g++ -c main.cpp    #用g++来将cpp文件编译成.o文件
  getop.o:getop.cpp
  g++ -c getop.cpp
  stack.o:stack.cpp
  g++ -c stack.cpp
  getch.o:getch.cpp
  g++ -c getch.cpp
  clean: 
  rm -f main.o getch.o getop.o stack.o
#+END_SRC
如果我们新增了一个文件, 那么我们需要在这个makefile文件里, 两处地方添加文件依赖, 可能会出现漏加的情况,因此我们引入一个变量来避免这个问题.
#+BEGIN_SRC makefile
  #version 2
  #由于版本1中,如果我们需要增加一个新的.o文件就需要手动修改三个地方,这在多任务下可能出现遗忘,因此引入makefile的变量即可
  objects=main.o getch.o getop.o stack.o
  maincc: $(objects)
  g++ $(objects) -o maincc
  main.o:main.cpp
  g++ -c main.cpp    #用g++来将cpp文件编译成.o文件
  getop.o:getop.cpp
  g++ -c getop.cpp
  stack.o:stack.cpp
  g++ -c stack.cpp
  getch.o:getch.cpp
  g++ -c getch.cpp
  .PHONY : clean
  clean:
  -rm maincc  *.o
#+END_SRC
这样, 我们只需要修改objects变量和下面的编译指令即可. 不过在此之前, 我们先解释一下最后的部分, 最后的部分作用其实就是删除中间文件和执行文件, 这可以保证我们文件干净. 这个-rm指的是如果有些文件不存在, 那就别管他继续往后删. .PHONY指的是clean是一个伪目标, 也就是不是一个文件.

事实上, 我们还可以进一步简化这个makefile文件,利用makefile的自动推导规则, 也就是makefile会自动推导出.o文件是由.cpp文件生成的, 因此我们可以将上面的makefile文件简化为
#+BEGIN_SRC makefile
#事实上,我们还可以对上面的版本进行简化,GNU下的make命令可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。
objects=main.o getch.o getop.o stack.o
maincc: $(objects)
	g++ $(objects) -o maincc
main.o:main.cpp
getop.o:getop.cpp
stack.o:stack.cpp
getch.o:getch.cpp
.PHONY clean: 
	rm -f  *.o
#+END_SRC
* 复杂声明(Chapter 5)
由于C语言设计指针的声明需要嵌套大量的括号且并不能简单的从左到右阅读, 因此给定一个复杂的声明, 我们极难快速分析出其含义. 在此, 我们需要写一个程序用来实现将C语言的复杂声明转换为文本, 同理还有一个将文本转为声明的程序.
** 设计思路
我们将声明符分为两类,一类是dcl,其主要是前面会带有可选的*号的direct-dcl,其主要用来处理指针类型;第二类则是direct-dcl,其主要是如name,(dcl),direct-dcl(),direct-dcl[]的类型.很显然无论声明是什么形式,我们都可以将其视作dcl的形式,因此我们只需要设计两个函数dcl和dirdcl即可.

在设计dcl和dirdcl函数之前,我们需要先设计一个用来读取输入类型的函数gettoken,其作用不仅仅是读取下一个输入流的输入,更是识别下一个输入的符号类型,并返回其类型.大体我们可以将记号类型分为如下几种:NAME,PARENS,可能包含数字的BRACKETS,以及其他任意单个字符.这里我们逐一分析输入情况,首先我们需要跳过初始输入的空格和制表符;其次如果我们接收到左括号,那么如果紧接着右括号,那么我们就返回PARENS,否则代表了左括号后面还有内容,因此我们需要将已读取的字符重新压入缓冲区,并返回左括号.如果我们接受到的是左方括号,那么其后面只可能跟进数字,无所谓内部内容,我们只需要通过循环找到右方括号即可,并返回BRACKETS;如果我们接收到的是字母,那么我们是在读取一个名称,为了简便起见,我们忽略变量名中出现下划线的情况,因此我们只需要判断后续字符是否是字母或者数字,直到遇到第一个非数字或字母的字符,我们将其压回缓冲区,并返回NAME;最后,如果我们接收到的是其他字符,那么我们直接返回该字符.

在设计完输入类型读取函数之后,我们开始设计dcl函数,首先由我们前面的dcl类型的声明定义可知,我们的dcl函数只去处理指针类型的声明,因此我们需要统计*的个数并且在出现第一个非*字符时表明我们进入了dirdcl类型之中;值得注意的是,我们在函数栈弹出回到dcl过程中的时候,因为一个*就代表了一个指针形式,因此我们需要循环添加pointer to语句.

对于dirdcl函数而言,如果输入标签为左括号,那么后续跟进的一定是dcl,值得注意的是,这样返回到dirdcl函数中的时候,我们需要进一步判断是否出现右括号,如果没有,则报错;如果输入标签为NAME,那么我们只需要输出这个名字即可;如果不是这两个形式的开头那么就需要报错.其次我们就要考虑后缀括号或方括号的情况:如果是括号,那么表示这是一个函数,我们只需要输出函数的形式即可;如果是方括号,那么表示这是一个数组,我们只需要输出数组的形式即可.
** 代码实现
main函数
#+BEGIN_SRC C++
#include<stdio.h>
#include<string.h>
#include<ctype.h>

#define BUFSIZE 100
#define MAXTOKEN 100
enum {NAME,PARENS,BRACKETS};
char buf[BUFSIZE];//缓冲区
int bufp = 0;//缓冲区空闲的后一位
int tokentype;//最后一个字符的类型: 类型名NAME，括号PARENS，方括号BRACKETS
char token[MAXTOKEN];// 最后一个token的字符串
char name[MAXTOKEN];// 声明的变量名
char datatype[MAXTOKEN]; // 声明的类型名
char out[1000];

int getch(void);
void ungetch(int c);
int gettoken(void);//用来读取下一个字符
void dcl(void);
void dirdcl(void);

int main()
{
	//读取输入
	while (gettoken() != EOF)
	{
		//第一个输入一定是类型名
		strcpy(datatype, token);
		out[0] = '\0';
		dcl();
		if (tokentype != '\n')
			printf("syntax error\n");
		printf("%s: %s %s\n", name, out, datatype);
	}
	return 0;
}
#+END_SRC
getch and ungetch(读取缓冲区与压入缓冲区)
#+BEGIN_SRC C++
int getch(void)
{
	return (bufp > 0) ? buf[--bufp] : getchar();
}
void ungetch(int c)
{
	if (bufp >= BUFSIZE)
		printf("ungetch: too many characters.\n");
	else
		buf[bufp++] = c;
}
#+END_SRC
dcl和dirdcl函数
#+BEGIN_SRC C++
//dcl的用处是处理指针符号
void dcl(void)
{
	int np;
	for (np = 0; gettoken() == '*'; np++);
	dirdcl();
	while (np--)
		strcat(out, " pointer to");
}
//dirdcl处理的是类型名dirdcl()/dirdcl[]，圆括号(dcl)
void dirdcl(void)
{
	int type;

	if (tokentype == '(')
	{
		dcl();
		if (tokentype != ')')
			printf("error: missing )\n");
	}
	else if (tokentype == NAME)//变量名
		strcpy(name, token);
	else
		printf("error: expected name or (dcl)\n");
	while ((type = gettoken()) == PARENS || type == BRACKETS)
	{
		if (type == PARENS)
			strcat(out, " function returning");
		else
		{
			strcat(out, " array");
			strcat(out, token);
			strcat(out, " of");
		}
	}
}
#+END_SRC
gettoken函数
#+BEGIN_SRC C++
int gettoken(void)
{
	int c;
	char* p = token;
	//处理空格
	while ((c = getch()) == ' ' || c == '\t');
	//处理括号	
	if (c == '(')
	{
		//完整括号
		if ((c = getch()) == ')')
		{
			strcpy(token, "()");
			return tokentype = PARENS;
		}
		//括号里有内容
		else
		{
			ungetch(c);
			return tokentype = '(';
		}
	}
	//处理方括号
	else if (c == '[')
	{
		for (; (*p++ = c) != ']'; c = getch());
		*p = '\0';
		return tokentype = BRACKETS;
	}
	//处理类型名和变量名
	else if (isalpha(c))
	{
		for (*p++ = c; isalnum(c = getch());)
			*p++ = c;
		ungetch(c);
		*p = '\0';
		return tokentype = NAME;
	}
	else
		return tokentype = c;
}
#+END_SRC
** Exercise 5-18
Make dcl recover from input errors.

这里给的解决办法就是如果出现问题,我们就跳转到行末,然后设置一个标志位,再下一次输入修正错误.因此我们只需要补一个错误设置函数即可.
#+BEGIN_SRC C++
void set_false(void)
{
	int c;
	if (tokentype != '\n')
		while ((c = getch()) != '\n')
			;
	tokentype = '\n';
	flag = 1;
}
#+END_SRC
* 字节对齐(Chapter 6)
现代计算机的内存空间是以Byte为基本单位划分的.从理论上说,我们可以将任意的数据类型存放在任意的内存空间之上,但实际上,在现代计算机中存在一种叫做字节对齐的机制,以保证数据存放依照一定的规则进行.所以对齐其实和数据在内存中的存放位置有关,如果一个变量的内存地址正好为他的整数倍,则称之为自然对齐.例如在32位系统中,如果一个int类型的地址为0x00000004,则为自然对齐.而我们接下来讨论的字节对齐主要针对自定义类型,例如结构体,联合体等.
** 字节对齐的作用和优势
字节对齐的作用主要是为了提高内存的访问速度,从而提高程序运行性能.这是因为访问未对齐的内存时,可能需要做两次内存访问,而后做一个内存拼接操作,才可以得到正确的数据.而如果我们按照字节对齐的思路来设计内存,那么我们每次只需要一次内存访问即可得到正确的数据.所以字节对齐的主要含义是牺牲空间来换取时间.

例如如果每次访问要么从0x01-0x04或0x05-0x08,硬件并不支持一次访问就可以从0x02-0x05.这样的话如果我们不对齐字节,是存在将int数据存储到0x02-0x05的可能性,这样的话我们就需要先读取一遍0x01-0x04,保留0x02-0x04;而后再读取一遍0x05-0x08,保留0x05;最后将二者拼接起来,才能得到正确的数据,如此就会降低程序的运行效率.
** 字节对齐的规则
*** 基本数据类型的自身对齐值
虽然我们所说的字节对齐主要针对自定义类型,但自定义类型实际上是基本数据类型的组合,因此我们需要先了解基本数据类型的自身对齐值,其实也就是基本数据类型的大小.由于不同的编译器和不同的操作系统对于基本数据类型的大小有不同的规定,我们以char为1字节,short为2字节,int为4字节,long为4字节,float为4字节,double为8字节为例进行讨论.
*** 自定义类型的自身对齐值
自定义类型的自身对齐值是指自定义类型(一般指struct,union)中的成员变量的自身对齐值中的最大值.在这样的对齐规则下,自定义类型的空间占用绝不是简单的成员变量的空间大小之和.我们将在后面的例子中给出相关例子以及计算空间的规则.
#+BEGIN_SRC C++
  struct A
  {
    char a; //1
    double b;//1
    int c;//1
  }
#+END_SRC
在计算结构体的空间占用时,具体流程如下:
1. 首先我们需要根据基本类型的自身对齐值来先初步判断结构体的空间占用;
2. 其次我们按照从上往下对齐的规则来进行第二步的字节对齐,即前面开辟的空间之和是下一个数据类型的整数倍即可,这里的整数倍特指大于空间之和的最小整数倍;
3. 最后,我们还要保证结构体的整体开辟空间是自身对齐值的整数倍,这样才能保证结构体的整体对齐.

这里其实我们可以发现,虽然我们做的字节对齐绝不是简单的在结构体空间的末尾加上一些空白空间,而是在适当位置加上空白空间,这样才能保证结构体的整体对齐.在上面这个例子中,我们已知char的自身对齐值为1, double的自身对齐值为8, int的自身对齐值为4;char与double对齐时,需要在其后面加上7个空白字节,使得开辟空间是double的整数倍;double与int对齐时,由于double和之前的char一共开辟了16个字节,而int是4个字节,已经是其整数倍,故不需要额外加空白字节;最后由于我们整个结构体开辟了20个字节,但是结构体的自身对齐值是成员变量的自身对齐值中的最大值,即8,所以我们需要在结构体的末尾加上4个空白字节,使得结构体的整体对齐值为8的整数倍.所以最终结构体的空间占用为24个字节.

从这里,我们其实可以意识到,尽管我们定义相同内容的结构体,由于不同的定义顺序,可能会导致结构体的空间占用不同.例如
#+BEGIN_SRC C++
  struct A
  {
    char a; //1
    int b;//1
    double c;//1
  }
#+END_SRC
这样的定义方式我们只需要开辟16个字节,因此我们可以看到,结构体的定义顺序是有一定的影响的.如果我们希望节省结构体定义的空间,我们可以在定义时按照基本数据类型的自身对齐值从小到大的顺序进行定义,这样可以减少结构体的空间占用.
*** 程序指定的自身对齐值
 在C/C++中,我们可以用#pragma pack(value)来指定程序中的自身对齐值,这样可以改变程序中的自定义类型的自身对齐值.这里如果value=1,则相当于取消对齐.这样的话自定义类型的空间就是成员变量的空间之和.这里设置的value一般而言是要求2的整数次幂,例如1,2,4,8,16等等.如此,我们可以根据实际情况来设置自定义类型的自身对齐值,从而节省空间.
 例如:
 #+BEGIN_SRC C++
   #pragma pack(4)
   struct A
   {
     char a;
     double b;
     int c;
   };
 #+END_SRC
这里由于我们设置了自身对齐值为4,这样的话我们按照上面的推导规则,char与double对齐时,因为我们显式设置了程序的字节对齐值为4,所以我们只需要在其后面补3个空白字节即可;double与int对齐时,因为之前开辟的空间是12个字节,int是4个字节,所以我们不需要补空白字节;最后我们看到整个结构体的空间占用为16个字节,这样他是我们设置的自身对齐值的整数倍,所以我们不需要再补空白字节.

值得注意的是,我们设置的自身对齐值是可能与前面提到的自定义类型的自身对齐值有冲突的,这时候,我们就需要讨论后续的对齐规则,也就是所谓的有效对齐值.
*** 自定义类型的有效对齐值
自定义类型的有效对齐值是指自定义类型的自身对齐值和程序指定的自身对齐值中的最小值.这样的话,我们可以根据有效对齐值来计算自定义类型的空间占用.例如
#+BEGIN_SRC C++
   #pragma pack(4)
   struct A
   {
     char a;
     short b;
     double c;
   };
 #+END_SRC
按照上面的规则,我们逐步分析,char与short对齐时,虽然我们设置了程序的字节对齐值为4,但是short的自身对齐值为2,所以我们只需要按照2字节对齐即可,所以我们只需要在char后面补一个空白字节即可;在short与double对齐时,因为之前开辟的空间是4个字节,而double的自身对齐值为8,但我们设置了程序的字节对齐值为4,所以我们不需要做什么操作;最后我们看到整个结构体的空间占用为12个字节,这样他是有效对齐值4的整数倍.
** 额外的情况
*** 联合体的字节对齐
上面我们讨论的都是结构体的字节对齐,但是联合体其实与之十分类似,但是由于结构体是为每个成员开辟了独立的空间,但是联合体则是所有成员共用一个空间,因此二者的空间占用计算是不同的.
#+BEGIN_SRC C++
  union A
  {
    char a[10];
    short b;
    double c;
  };
#+END_SRC
在这个例子中,我们可以意识到,如果我们分别为不同的成员开辟空间,那么我们需要为char[10]开辟10个字节,为short开辟2个字节,double开辟8个字节,根据联合体的定义,我们只需要开辟最大的成员的空间,即10个字节;但值得注意的是,联合体的空间占用也是需要满足字节对齐的,联合体的自身对齐值是其成员的自身对齐值的最大值,也就是8.同样我们也需要要求联合体整体空间是自身对齐值的整数倍,因此我们只需要在联合体的末尾加上6个空白字节即可,使得联合体的整体对齐值为8的整数倍.

这里我们要强调的是,我们所说的自身对齐值指针对变量类型,而不是变量的大小,就像我们这个例子所提到的char[10],他的对齐值是1,而不是10.
*** 内嵌结构体的字节对齐
在实际使用中,我们可能会出现需要在struct中嵌套struct的情况.我们按照上面的思想对其进行分析,
#+BEGIN_SRC C++
  struct A
  {
    short a;
    struct
    {
      double b[10];
      int c;
      char d;
    }
    long e; 
  };
#+END_SRC
我们先从内部的struct分析,double b[10]需要开辟80个字节,但其的对齐值是8.double和int对齐时,double[10]开辟出的80个空间是int的整数倍,所以我们不需要额外补充空白字符;int与char对齐时,int以前开辟的空间为84个字节,是char的整数倍.因此不需要开辟空白字节;但是由于内部的struct的自身对齐值为8,所以我们需要在末尾补上3个字符,使得整体开辟88个字节,符合struct的自身对齐值的整数倍.但是值得注意的是,如果我们分析struct A的时候,内部struct的对齐值并不是88,而是其成员类型的最大对齐值.所以我们可以开始分析struct A.short与内部struct对齐时,short的字节空间为2,并不是内部struct的整数倍,因此我们需要在short后面补6个空白字节,使得short的空间为8的整数倍;内部struct与long对齐时,内部struct的空间以前开辟的空间为96,是long的整数倍,所以我们不需要额外开辟空白字节.最后我们看到整个struct A的空间占用104个字节,这样他是struct A的自身对齐值的整数倍.

但是这里我们需要注意的是,如果我们在内部struct给了一个类型命名,那么struct A的字节占用会有一个很大的变化,如
#+BEGIN_SRC C++
 struct A
  {
    short a;
    struct t
    {
      double b[10];
      int c;
      char d;
    }
    long e; 
  };
#+END_SRC
这样的话,我们会认为struct t是一个内嵌类型,并不会为只分配空间,所以也就是说,struct t的类型定义和typedef的作用是一样的,并不会为其分配空间.所以我们在分析struct A的时候,只需要按照除了内部struct以外的成员变量来分析即可.但是值得注意的是,这里如果我们定义了变量的话,那么就需要考虑空间占用.

其次我们上面讨论的内嵌类型只针对C++,在C中并没有这样的概念,所以在C中,我们需要为内嵌类型分配空间.
* 位域与柔性数组(Chapter 6)
我们在前面提到了用空间换时间的字节对齐规则,会发现结构体其实会浪费很多的空间以用来提高程序运行速度.在这一部分,我们将讨论结构体中的节省空间的技巧,也就是所谓的位域和柔性数组.
** 位域
我们先考虑如下的实际例子,我们需要判断一个变量是否为extern,static以及关键字.如果我们用最为直接的方式,我们只需要设置多个char变量作为flag,分别设置0或1,来表示是否的二元状态.但是这样的话,我们需要开辟多个字节的空间,这样会浪费很多的空间.

我们先利用屏蔽码集合来解决这个问题,如
#+BEGIN_SRC C++
  #define KEYWORD 01
  #define EXTERNAL 02
  #define STATIC 04 
#+END_SRC
值得注意的是,这些数字必须是2的幂次;这样我们就可以通过位运算来进行判断.例如:
#+BEGIN_SRC C++
  flag|=EXTERNAL|STATIC;//将flag的external和static位置为1
  flah&=~(EXTERNAL|STATIC);//将flag的external和static位置为0
#+END_SRC


位域指信息在存储时,并不需要占用一整个字节，而只需要占用一个或几个二进制位即可.例如,如果我们设置多个flag,分别用于判断变量是否为extern,static或const;常见的做法是用三个char变量来存储这三个flag,但这样的话,我们需要开辟三个字节的空间,然而实际上flag的取值只有0和1两个状态,因此我们完全可以只使用一个二进制位来存储每个flag.这样的话,我们只需要开辟一个字节的空间即可.这样的技巧就是位域.
#+BEGIN_SRC C++
  struct
  {
    unsigned int is_keyword:1;
    unsigned int is_external:1;
    unsigned int is_static:1;
  } flags;
#+END_SRC
这样他只开辟了一个unsigned int的空间.其调用和正常的结构体成员一样,通过StructName.BitName来调用.位域的使用方法大体需要遵循如下几点:
1. 定义位域时,可以指定成员的位域宽度,即成员所占的位数
2. 位域的宽度不能超过其类型的位数,因为位域必须适用于所用的整数类型(如int,unsigned int等)
3. 位域可以单独使用,也可以和其他成员一起使用,如
   #+BEGIN_SRC C++
     struct
     {
       int a:1;
       int b;
       int c:2;
      };
   #+END_SRC
我们进一步讨论位域的几个空间占用的问题:
 1. 不可以跨字节存储,如
    #+BEGIN_SRC C++
      struct
      {
        char a:3;
        char b:4;
        char c:5;
      };
    #+END_SRC
这里我们需要开辟9个二进制位,但是char只有8个二进制位,因此我们需要开辟两个字节.但实际上我们会发现,a和b已经占用了7个二进制位,因此一个字节只剩下了1个空闲的二进制位,但是c需要5个二进制位,因此我们会选择空闲掉这个空间,开辟一个新的字节空间来存储c.
2. 不可以跨类型存储,如
   #+BEGIN_SRC C++
     struct
     {
       char a:1;
       int b:1;
     };
   #+END_SRC
虽然这个例子里面,我们只需要两个二进制位,但我们发现这两个变量的类型不同,因此我们不能仅开辟一个字节的空间,而应该按照对应类型大小开辟.char开辟1个字节,但其需要与int对齐,所以需要额外开辟3个空闲字节;int则需要开辟4个字节,这样一共开辟8个字节.实际上在GCC下,只需要开辟4个字节,这是一种极度节省空间的方法,先开辟类型最大的空间,然后再根据实际情况来存储.
在位域中,还有一些特殊的用法,如:
1. 无名位域:位域成员可以没有名字,只给出数据类型和位宽,
   #+BEGIN_SRC C++
     struct
     {
        int m: 12;
        int  : 20;  //该位域成员不能使用
        int n: 4;
     };
   #+END_SRC
   这里的无名位域的作用一般用于填充或调整成员位置.并且因为其没有名字,所以无名位域是不可以被使用的.
2. 位域的大小为0:这表示该位域为空域,其只能在无名位域中使用,下一个域则以下一个类型单元开始存放,如
   #+BEGIN_SRC C++
     struct
     {
        char m: 1;
        short l:2;
        int  : 20;  //该位域成员不能使用
        int n: 4;
     };
   #+END_SRC
   这里的n会在第四个字节开始存放.
** 柔性数组
柔性数组的产生其实是与coding中对动态结构体的需求有关.在日常的编程中,我们可能希望在结构体里存放一个长度是动态的数组,一般的做法是在结构体中定义一个指针成员,用这个指针指向一个动态开辟的数组空间.然而这一操作会对内存管理带来极大的困扰,因为我们需要在使用完这个结构体后,手动释放这个指针指向的空间.而柔性数组其实就是在结构体中存放一个长度动态的数组.
*** 柔性数组的使用
#+BEGIN_SRC C++
  struct Test
  {
    char a;
    double b;
    int c[0];
  }
#+END_SRC
柔性数组成员的两个特征:
1. 柔性数组成员只能是结构体的最后一个成员
2. 柔性数组成员的数组长度为0,因此柔性数组成员不占用结构体的空间.故上面的struct空间为16个字节.
因此,对于柔性数组,我们可以按照如下角度来理解:
1. 柔性方面:柔性数组成员的长度是动态的,所管理的空间可大可小,因此我们可以根据实际情况来动态调整空间大小.
2. 数组成员方面:形式为数组形式,但大小为0,其次,被定义在结构体内部.
*** 传统结构体指针成员使用
如果我们仅考虑静态的结构体,可能并不是很容易体现柔性数组的优势,但如果我们考虑结构体的动态生成,就会十分明显的体现出柔性数组的优势.例如:
#+BEGIN_SRC C++
  #include<stdio.h>
  #include<malloc.h>
  typedef struct Test
  {
      int size;
      int* ptr;
  }Test;
  int main()
  {
      int sz = 10;
      Test* pt = (Test*)malloc(sizeof(Test));
      pt->ptr = (int*)malloc(sizeof(int) * sz);
      pt->size = sz;
      for (int i = 0; i < pt->size; i++)
          pt->ptr[i] = i + 1;
      for (int i = 0; i < pt->size; i++)
          printf("%d ", pt->ptr[i]);
      printf("\n");
      free(pt->ptr);
      free(pt);
  }
#+END_SRC
这里我们可以发现,传统方式下有两个缺点:
1. 结构体成员ptr是一个指针,因此我们需要为之开辟空间.
2. 对于申请的结构体空间和指针空间,我们需要分开申请和释放;因此这并不利于内存管理,及其容易出现内存泄漏的问题,从而导致程序运行效率低下.
*** 柔性数组成员的使用
柔性数组成员的使用可以很好的解决上面的问题,
#+BEGIN_SRC C++
#include<stdio.h>
#include<malloc.h>
typedef struct Test
{
	int size;
	int ptr[0];
}Test;
int main()
{
	int sz = 10;
	Test* pt = (Test*)malloc(sizeof(Test)+sizeof(int)*sz);
	pt->size = sz;
	for (int i = 0; i < pt->size; i++)
		pt->ptr[i] = i + 1;
	for (int i = 0; i < pt->size; i++)
		printf("%d ", pt->ptr[i]);
	printf("\n");
	free(pt);
}
#+END_SRC
这里其实主要的区别在于,我们在malloc的时候不仅为结构体开辟了空间,还为柔性数组开辟了空间.我们可以这么理解柔性数组成员,柔性数组成员其实就是一个指针,这个指针指向紧贴着结构体空间后的空间,当我们同时开辟结构体和柔性数组空间时,柔性数组成员其实就是指向柔性数组空间的首元素.因此,我们不需要将开辟空间的操作分开,而是一次性完成,这样就很好的解决了内存管理的问题.
* 输入和输出(Chapter7)
** 标准输入输出
标准的输入设备一般指键盘,而标准的输出设备一般指屏幕.我们一般使用EOF作为判断输入流结束的标志,而符号常数EOF在头文件<stdio.h>中定义,一般而言其值会被设定成-1.在Windows电脑下,我们可以通过Ctrl+Z来输入EOF,而在Linux下,我们可以通过Ctrl+D来输入EOF;特别注意的是Ctrl+Z必须在行首输入,如果使用的是VS,则需要连续输入三次Ctrl+Z才可以发送EOF.

我们可以通过符号<来实现输入重定向,其可将键盘输入替换为文件输入,如
#+BEGIN_SRC eshell
  prog <infile //将infile文件的内容作为prog的输入,这里的prog是一个可执行文件
#+END_SRC
这样的重定向会是prog的输入流来自于infile文件,而不是键盘输入.值得注意的是,虽然我们在命令行中会通过这个操作做输入重定向,但是这并不会被视作命令行参数,因为对于程序而言,从什么来源获得输入流并不重要. 进一步, 我们可以通过管道机制,将一个程序的输出作为另一个程序的输入,如
#+BEGIN_SRC shell
  prog1 | prog2 //将prog1的输出作为prog2的输入
#+END_SRC
相应的,我们可以通过符号>来实现输出重定向,其可以将屏幕输出替换为文件输出,如
#+BEGIN_SRC shell
  prog >outfile //将prog的输出重定向到outfile文件中
#+END_SRC
这样的重定向会将prog的输出流输出到outfile文件中,而不是屏幕输出.

这里我们需要注意的是,这些重定向操作主要是在Unix环境下可行的,如果我们在Windows系统下的cmd中利用<做输入重定向,他是会报错的;所以如果我们需要在Windows系统下进行输入输出重定向,我们需要利用管道操作:
#+begin_src shell
  Get-Content infile | .\prog.exe
#+end_src
但是输出重定向可以正常使用.
** Printf函数
主要是对于精度和宽度的控制的一些补充,%m.n的形式解释的比较模糊，具体对不同的类型有不同的效果；
1. 对字符串类型(字符数组)而言，m用来控制输出的长度，如果长度超过m，则忽略其存在，不然则以右对齐，并做空格补全，n表示控制输出的字符个数，一旦n大于字符长度则完成字符输出即可
2. 对整型数据而言，m用来控制输出长度，如果长度超过m，则忽略其存在，不然则以右对齐，并做空格补全，n则用于控制其输出数字长度，如果n大于其长度，那么会在输出的int左端补0；不然则默认输出。
3. 对浮点型数据而言，n指的是控制输出的小数部分，如果n大于小数部分的长度，那么就四舍五入；反之则在后面补0；在n控制了以后，如果长度超过了m，那么就完整输出；不然就在左侧补空格
** Variable-length argument lists
我们通过查看printf的函数声明可以发现,printf的参数列表是一个可变长参数列表,其声明如下:
#+BEGIN_SRC C
  int printf(const char* format, ...);
#+END_SRC
这里的...表示可变长参数列表.在C语言中,头文件stdarg.h中定义了一组宏,这些宏可以帮助我们遍历可变长参数列表.

1. va_list类型用于声明一个变量,其将一次引用各参数,一般用ap来记作va_list类型变量,其为argument pointer的缩写.
2. va_start将ap初始化为指向第一个无名参数的参数指针.在使用ap之前,必须先调用va_start.此外,参数列表中必须存在一个有名参数,以便va_start能够找到无名参数列表的起始位置.
3. va_arg将返回一个参数,并将安排指向下一个参数.va_arg使用一个类型名来决定返回的对象类型,指针移动的步长.
4. va_end必须在函数返回前调用,其将完成一些必要的清理工作.
** Scanf 函数
scanf的一些进一步说明：
1. 空白字符会使scanf函数在读操作中略去输入中的一个或多个空白字符。空白字符可以是空格，制表符和新行符。非空白符使得scanf函数在读取过程中剔除与这个非空白字符相同的字符。
2. 控制串中的空白符使scanf在输入流中跳过一个或多个空白行。本质上，控制串中的空白符使scanf在输入流中读取，但不保存结果直到遇到第一个非空白字符
3. 如果format写的是“%d,%d”那么输入的时候也要用,作为分隔符；如果没有写，那么就需要用空格或制表符等空白字符。
4. 虽然scanf会忽略空白字符，但是在读取单字符时，其并不会被忽略；并且scanf在读取字符串时，遇到空白字符会中断读取，只记录空白字符以前的，我们可以通过额外设置参数，来使其读取

这里有个很好玩的点需要注意,double类型的变量在scanf中的占位符是%lf,而不是%f,因为%f会损失一些精度;但是在printf其占位符可以是%f. 还有一些sscanf之类的,其实只是将scanf的输入流换成了字符串流,其余的操作都是一样的.
** File Access
cat命令用于链接文件并打印到标准输出设备上,其主要作用是用于查看和链接文件内容.我们可以利用输入输出重定向的方式,用其覆盖文件内容,>是输出重定向,会覆盖原文件的内容;>>则是在原有的文件的基础上追加内容.

在读取文件内容之前,需要用fopen函数来打开外部文件,此时返回文件指针,后续会用于读取和写入文件内容.文件指针指向一个结构体,其中包含文件的信息,如缓冲区的位置,缓冲区当前的字符位置,文件是否正在被读取或写入以及是否有错误或到达文件末尾.但这个已经在stdio.h封装完成,用户不需要考虑这些细节.
#+BEGIN_SRC C++
FILE* fp=fopen(name,mode);
#+END_SRC
name表示文件路径,且其中需要包含文件名;mode则表示如何使用打开的文件,'r'表示只读,'w'表示只写,'a'表示追加.如果某些系统将文件分为文本文件和二进制文件,那么对于后者的模式我们必须在模式字符串后加上'b',如'wb'表示以二进制方式打开文件进行写操作.值得注意的是,如果我们对于文件采用写或者追加操作,即使文件不存在,系统也会试图创建一个文件.但是写和追加操作的不同在于,写操作会完全覆盖原有文件内容,而追加操作则是在保持原有文件的基础之上在其后追加内容.而我们如果对于文件采用读操作,那么一旦文件不存在,系统就会报错;一旦fopen报错,他的返回值就是NULL.

getc返回文件的下一个字符,其需要输入一个文件指针,用来表明其要读取的文件.如果到文件末尾或者读取文件发生错误,那么其会返回EOF;putc则是getc的反面,其作用则是一个输出函数,将字符c写入到fp指向的文件,并返回写入的
字符.如果发生错误,则返回EOF.值得注意的是,getc和putc并不是函数而是一个宏.
#+begin_src C++
  int getc(FILE *fp)
  int putc(int c,FILE *fp)
#+end_src
当一个C语言程序运行的时候,操作系统会自动打开标准输入,标准输出和标准错误三个文件,并提供相应的三个文件指针stdin,stdout,stderr.这三个文件指针在头文件stdio.h中给出声明.一般而言,stdin对应于键盘,stdout和stderr对应于屏幕;但是stdin和stdout可以通过输入输出重定向或者管道操作来将对应的设备进行修改.

getc和putc提供了从文件读写单个字符的方式,而类似于scanf和printf,我们同样有从文件中格式化读写的函数fscanf和fprinf
#+begin_src C++
  int fscanf(FILE* fp,char* format,...)
  int fprintf(FILE* fp,char* format,...)
#+end_src
其与正常的scanf和printf的区别在于,他需要在第一个参数提供一个指向读写的文件的指针,第二个则是格式串.

最后,我们在完成对文件的操作以后,我们需要用fclose来断开文件指针和外部文件的链接,并释放文件指针以供其他文件使用.这是因为大部分的操作系统其实控制了一个程序最多可以同时打开的文件数.因此如果我们不需要某个文件,应该及时关闭.fclose的另一个作用其实就是会强制将缓冲区中尚未写入磁盘的剩余数据立即刷新到文件中,其可以保证缓冲区数据正确保存.而缓冲区的存在是因为当程序如果频繁调用putc或者fprintf等函数向文件写入数据,如果每次写入操作都要操作磁盘,那么程序运行就会十分低效;因此就需要用缓冲区,数据会先暂存在内存的缓冲区中,当缓冲区被填满时,系统才会直接写入磁盘,这样可以减少磁盘操作的次数,显著提升了程序性能.如果最后没有用fclose,虽然大部分系统执行完程序会自动刷新缓冲区,但一旦出现程序异常终止可能就会有数据泄漏的风险.

如果我们不需要stdin和stdout,实际上也可以用fclose把他们关闭了,如果我们需要可以用freopen函数把他重新打开,一般来是重新打开会把标准输入输出文件重定向为本地文件.
** Error Handing
这里我们需要明确的是,前面所提到的输入输出重定向和管道操作是针对stdout和stdin的,而srderr是独立于stdout的一个文件指针,故其一直指向屏幕.其次,标准库函数exit()也提供了一种终止调用程序的执行方式.任何调用这个程序的参数进程都可以获得exit的参数值.因此可以借此来定位程序的报错位置.一般而言,参数值0表示一切正常,而非0值则表示出现了异常情况.exit的调用会为已经打开的输出文件调用fclose函数,以将缓冲区中的所有输出写入相应的文件.

在shell中运行的每个命令都用了退出状态码,退出状态码一般是一个0~255的整数值,在命令结束的时候会由命令传给shell. Linux中给出了一个专属变量?来保存上一个执行命令的退出状态码,必须要在查看的命令后马上查看.
#+begin_src shell
  echo $?
#+end_src
默认状态下,shell会以脚本中的最后一个命令作为退出状态码.exit()其实可以自定义制定shell命令的退出状态码.由于退出状态码的取值范围为0~255,所以如果不在这个范围内,会通过取模运算来使其控制在范围内.


exit函数的优势在于:
1. 其可以在其他函数调用,而不仅仅是main函数中调用.
   
exit()是一个库函数,通常定义在stdlib.h.这个函数的主要功能是终止程序的执行并返回一个状态码到调用进程,一般是os或者是shell.由于exit只是一个库函数,因此可以在程序的任何位置,任何函数或方法内部调用,而不仅仅在main,这意味着只要在运行过程中遇到了不可恢复的错误或者某个特定的错误条件,可以立即调用exit来终止程序,不需要用多层函数调用一直返回到main函数.

2. 可以用模式查找程序查找这些调用.
   
当我们正在维护或者调试大型程序,可以用模式匹配工具快速定位所有调用exit的位置.这是因为很多情况过早或过晚进行程序终止可能导致了代码的bug.

exit是一个带参数的函数,执行完以后会将控制权交给内核;而return只是一个关键字,其执行完会将控制权交给调用函数而非内核.其次,我们讨论exit()和_exit()的差异;exit()需要处理一些善后工作后,再将控制权交给内核,而_exit()则是立即将控制权交给内核.因此exit()其实是_exit()的一个封装,其流程如下所示:
1. exit函数逆序调用通过atexit或者on_exit登记的终止处理程序;
2. 然后按需多次调用fclose,关闭所有标准I/O流;
3. 删除由tmpfile函数创建的临时文件.
完成在用户空间所需要做的事情后,exit()就可以调用_exit()来让内核处理终止进程的剩余工作.

注意的是接下来介绍的函数并不是用来判断文件操作是否出现错误,而是在文件操作已经出现错误的时候用来检查错误的原因和类型.

函数ferror的函数原型为
#+BEGIN_SRC C++
int ferror(FILE* stream);
#+END_SRC
ferror函数用于判断使用某个文件指针的过程中,是否发生了错误;如果使用过程中没有错误,那么ferror函数返回0;否则,ferror函数将返回一个非零的值.调用ferror函数时,我们只需要将待检查的文件指针传入即可.

函数feof的函数原型为
#+BEGIN_SRC C++
int feof(FILE* stream);
#+END_SRC
feof函数判断文件是否读取到文件末尾.如果文件没有到达文件末尾,那么feof函数返回0;否则,feof函数将返回一个非零值.因为feof其实是通过判断fp是否已经读取到了EOF字符,所以我们在调用feof函数之前需要用fgetc函数或者fgets函数读取,然后再判定.
** Line Input and Output
标准库提供了一个从文件中读取行的函数fgets,其函数原型为
#+begin_src C++
char *fgets(char *line,int maxline,FILE *fp)
#+end_src
fgets函数从fp指向的文件中读取下一个输入行(包括换行符),将其存放到字符数组line中.输入的maxline表示最多一次性读取maxline-1个字符,这是因为字符串的最后的字符是需要用'\0'占据,因此只能输入maxline-1个字符.通常情况,fgets返回line,如果遇到了文件结尾或者发生了错误,则返回NULL.

输出函数fputs将一个字符串(不需要包含换行符)写入到一个文件中:
#+BEGIN_SRC C++
int fputs(char *line,FILE *fp)
#+END_SRC
如果发生错误,该函数会返回EOF,否则会返回一个非负值. 与fgets,fputs类似的是,C语言提供了gets和puts两个库函数,但他们只对stdin文件和stdout文件进行操作.需要注意的是,gets函数在读取字符串时将删除结尾的换行符,而puts函数在写入字符串时则会在结尾补上一个换行符.
** Miscellaneous Functions
*** Command Execution
函数system(char*s)执行包含在字符串s的命令,然后继续执行当前程序.而s的内容则很大程度上与使用的操作系统有关.在Unix环境下,有如下demo
#+BEGIN_SRC C++
system("date");
#+END_SRC
会先去执行程序date,其就是在标准输出上输出当天的日期和时间.system函数会返回一个整型的状态值,其值来自于执行的命令并于具体的系统有关.在UNIX系统中其返回exit的状态值.
*** 存储管理函数
malloc函数的函数声明如下所示:
#+BEGIN_SRC C++
void *malloc(size_t n);
#+END_SRC
当分配成功时,其会返回一个无类型指针,该指针指向一个n个字节长度的空闲空间,但是这些空间是没有经过初始化的.我们需要先对无类型指针做一个强类型转换,同时对得到指针指向的空间初始化或者赋值;分配失败则会分配NULL.

calloc函数的函数声明如下所示:
#+BEGIN_SRC C++
void *calloc(size_t n,size_t size);
#+END_SRC
与malloc不同,calloc接受两个参数,第一个表示要被分配的元素个数,第二个表示元素的空间占用大小.所以其实calloc可以视作就是malloc的更为灵活的一个版本,但是与malloc不同的是,calloc分配的空间是会被默认初始化为0的.

realloc函数的函数声明如下所示:
#+BEGIN_SRC C++
void* realloc(void *ptr,size_t size)
#+END_SRC
realloc的作用是重新分配内存空间,在动态分配中十分重要,一般适用于调整之前用malloc或者calloc开辟的空间大小.

参数ptr指向一个需要重新分配的内存块,该内存块是之前由malloc,calloc或者realloc开辟的,也就是其需要可以动态分配的才可以;如果很特殊,我们考虑一个空指针,那么就会重新分配一个新的内存块,函数会返回一个指向他的指针.size为内存块的大小;特殊的情况为如果size=0且ptr非0那么就会释放ptr,并返回空指针.

如果空间分配成功,realloc返回指向新内存块的指针;否则,返回NULL,并且原来的内存块仍然保持不变(并没有释放).值得强调的是,realloc可能会将内存块移动到新地方(如果在原位置没有足够的空间容纳新的大小).如果移动成功,ptr会指向新位置.需要特别注意,旧的ptr指针需要被更新为realloc返回的新地址.如果内存分配失败,realloc返回NULL,而原始的内存块不会被释放.为避免内存泄漏,应该使用一个临时指针来接收realloc的返回值,并检查是否为NULL.
* The Unix System Interface
Unix系统提供了一系列的系统调用,这些系统调用其实是操作系统内部的程序
